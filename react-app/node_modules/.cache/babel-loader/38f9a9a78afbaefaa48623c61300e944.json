{"ast":null,"code":"export function dfs(grid) {\n  setNodesAsWalls(grid);\n  const startNode = grid[0][0];\n  const visited = [];\n  const stack = [];\n  stack.push(startNode); //console.log(visited);\n\n  let i = 0;\n\n  while (i < 50) {\n    const currentNode = stack.pop(); //console.log('currentNode', currentNode);\n\n    visited.push(currentNode);\n    const neighbors = getNeighbors(currentNode, grid, visited);\n\n    for (let i = neighbors.length; i > 0; i--) {\n      let temp = Math.floor(Math.random() * i);\n      temp = neighbors.splice(temp, 1);\n      stack.push(temp[0]);\n    }\n\n    currentNode.isWall = false;\n    i += 1;\n  }\n}\n\nfunction getNeighbors(node, grid, visited) {\n  // prettier-ignore\n  const neighbors = [];\n\n  for (const i of [[0, -2], [0, 2], [-2, 0], [1, 0]]) {\n    console.log('hei node', node);\n    const temp = [node.row + i[0], node.col + i[1]]; // check if the neighbor node is within the grid bounds\n\n    if (temp[0] < 0 || temp[0] > 29 || temp[1] < 0 || temp[1] > 49) {\n      continue;\n    }\n\n    ;\n    const neighbor = grid[temp[1]][temp[0]];\n\n    if (!visited.includes(neighbor) && neighbor.isWall) {\n      neighbors.push(neighbor);\n    }\n  }\n\n  return neighbors;\n}\n\nfunction setNodesAsWalls(grid) {\n  grid.forEach(row => {\n    row.forEach(node => {\n      node.isWall = true;\n    });\n  });\n}","map":{"version":3,"sources":["C:/My Projects/pathing-Algorithms/react-app/src/algorithms/mazeGen/depthFirst.js"],"names":["dfs","grid","setNodesAsWalls","startNode","visited","stack","push","i","currentNode","pop","neighbors","getNeighbors","length","temp","Math","floor","random","splice","isWall","node","console","log","row","col","neighbor","includes","forEach"],"mappings":"AAEA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAkB;AACrBC,EAAAA,eAAe,CAACD,IAAD,CAAf;AACA,QAAME,SAAS,GAAGF,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAAlB;AACA,QAAMG,OAAO,GAAG,EAAhB;AACA,QAAMC,KAAK,GAAG,EAAd;AACAA,EAAAA,KAAK,CAACC,IAAN,CAAWH,SAAX,EALqB,CAMrB;;AAEA,MAAII,CAAC,GAAG,CAAR;;AACA,SAAMA,CAAC,GAAG,EAAV,EAAa;AACT,UAAMC,WAAW,GAAGH,KAAK,CAACI,GAAN,EAApB,CADS,CAET;;AACAL,IAAAA,OAAO,CAACE,IAAR,CAAaE,WAAb;AACA,UAAME,SAAS,GAAGC,YAAY,CAACH,WAAD,EAAcP,IAAd,EAAoBG,OAApB,CAA9B;;AACA,SAAK,IAAIG,CAAC,GAAGG,SAAS,CAACE,MAAvB,EAA+BL,CAAC,GAAG,CAAnC,EAAsCA,CAAC,EAAvC,EAA0C;AACtC,UAAIM,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBT,CAA3B,CAAX;AACAM,MAAAA,IAAI,GAAGH,SAAS,CAACO,MAAV,CAAiBJ,IAAjB,EAAsB,CAAtB,CAAP;AACAR,MAAAA,KAAK,CAACC,IAAN,CAAWO,IAAI,CAAC,CAAD,CAAf;AACH;;AACDL,IAAAA,WAAW,CAACU,MAAZ,GAAqB,KAArB;AACAX,IAAAA,CAAC,IAAE,CAAH;AACH;AAEJ;;AAED,SAASI,YAAT,CAAsBQ,IAAtB,EAA4BlB,IAA5B,EAAkCG,OAAlC,EAA2C;AACvC;AACA,QAAMM,SAAS,GAAG,EAAlB;;AACA,OAAK,MAAMH,CAAX,IAAgB,CAAC,CAAC,CAAD,EAAI,CAAC,CAAL,CAAD,EAAS,CAAC,CAAD,EAAI,CAAJ,CAAT,EAAgB,CAAC,CAAC,CAAF,EAAK,CAAL,CAAhB,EAAwB,CAAC,CAAD,EAAI,CAAJ,CAAxB,CAAhB,EAAiD;AAC7Ca,IAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ,EAAuBF,IAAvB;AACA,UAAMN,IAAI,GAAG,CAACM,IAAI,CAACG,GAAL,GAAWf,CAAC,CAAC,CAAD,CAAb,EAAkBY,IAAI,CAACI,GAAL,GAAWhB,CAAC,CAAC,CAAD,CAA9B,CAAb,CAF6C,CAG7C;;AACA,QAAGM,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAV,IAAeA,IAAI,CAAC,CAAD,CAAJ,GAAU,EAAzB,IAA+BA,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAzC,IAA8CA,IAAI,CAAC,CAAD,CAAJ,GAAU,EAA3D,EAA8D;AAAC;AAAS;;AAAA;AACxE,UAAMW,QAAQ,GAAGvB,IAAI,CAACY,IAAI,CAAC,CAAD,CAAL,CAAJ,CAAcA,IAAI,CAAC,CAAD,CAAlB,CAAjB;;AACA,QAAG,CAACT,OAAO,CAACqB,QAAR,CAAiBD,QAAjB,CAAD,IAA+BA,QAAQ,CAACN,MAA3C,EAAmD;AAC/CR,MAAAA,SAAS,CAACJ,IAAV,CAAekB,QAAf;AACH;AACJ;;AACD,SAAOd,SAAP;AACH;;AAED,SAASR,eAAT,CAAyBD,IAAzB,EAA8B;AAC1BA,EAAAA,IAAI,CAACyB,OAAL,CAAaJ,GAAG,IAAI;AAChBA,IAAAA,GAAG,CAACI,OAAJ,CAAYP,IAAI,IAAI;AAChBA,MAAAA,IAAI,CAACD,MAAL,GAAc,IAAd;AACH,KAFD;AAGH,GAJD;AAMH","sourcesContent":["\r\n\r\nexport function dfs(grid){\r\n    setNodesAsWalls(grid);\r\n    const startNode = grid[0][0];\r\n    const visited = [];\r\n    const stack = [];\r\n    stack.push(startNode);\r\n    //console.log(visited);\r\n\r\n    let i = 0;\r\n    while(i < 50){\r\n        const currentNode = stack.pop();\r\n        //console.log('currentNode', currentNode);\r\n        visited.push(currentNode);\r\n        const neighbors = getNeighbors(currentNode, grid, visited);\r\n        for (let i = neighbors.length; i > 0; i--){\r\n            let temp = Math.floor(Math.random() * i);\r\n            temp = neighbors.splice(temp,1)\r\n            stack.push(temp[0]);\r\n        }\r\n        currentNode.isWall = false;\r\n        i+=1;\r\n    }\r\n\r\n}\r\n\r\nfunction getNeighbors(node, grid, visited) {\r\n    // prettier-ignore\r\n    const neighbors = [];\r\n    for (const i of [[0, -2],[0, 2],[-2, 0],[1, 0]]) {\r\n        console.log('hei node',node);\r\n        const temp = [node.row + i[0], node.col + i[1]];\r\n        // check if the neighbor node is within the grid bounds\r\n        if(temp[0] < 0 || temp[0] > 29 || temp[1] < 0 || temp[1] > 49){continue};\r\n        const neighbor = grid[temp[1]][temp[0]];\r\n        if(!visited.includes(neighbor) && neighbor.isWall) {\r\n            neighbors.push(neighbor);\r\n        }\r\n    }\r\n    return neighbors;\r\n}\r\n\r\nfunction setNodesAsWalls(grid){\r\n    grid.forEach(row => { \r\n        row.forEach(node => {\r\n            node.isWall = true\r\n        });\r\n    });\r\n\r\n}"]},"metadata":{},"sourceType":"module"}