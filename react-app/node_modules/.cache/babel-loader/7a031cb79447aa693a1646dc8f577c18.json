{"ast":null,"code":"export function recursiveDivision(grid, row, col, height, width, orientation) {\n  if (width < 2 || height < 2) return;\n  let isHorizontal = orientation; //get the column or row that a wall will be drawn in\n\n  const wallrow = row + (isHorizontal ? 0 : Math.floor(Math.random() * (width - 2)));\n  const wallcol = col + (isHorizontal ? Math.floor(Math.random() * (height - 2)) : 0);\n  console.log(\"wallrow\", wallrow);\n  console.log(\"wallcol\", wallcol); //random node in the wall will be selected as a passage\n\n  const passageRow = wallrow + (isHorizontal ? Math.floor(Math.random() * (width - 1)) : 0);\n  const passageCol = wallcol + (isHorizontal ? 0 : Math.floor(Math.random() * (height - 1)));\n  console.log(\"passrow\", passageRow);\n  console.log(\"passcol\", passageCol); //draw the wall\n\n  if (isHorizontal) {\n    for (let i = 0; i < width; i++) {\n      if (getNeighbors1(grid[i][wallcol], grid)) {\n        break;\n      }\n\n      grid[i][wallcol].isWall = true;\n    }\n  } else {\n    for (let i = 0; i < height; i++) {\n      if (getNeighbors2(grid[i][wallcol], grid)) {\n        grid[wallrow][i].isWall = true;\n      }\n    }\n  }\n\n  grid[passageRow][passageCol].isWall = false;\n  let newHeight1 = height;\n  let newHeight2 = height;\n  let newWidth1 = width;\n  let newWidth2 = width;\n\n  if (isHorizontal) {\n    newHeight1 = wallcol + 1;\n    newHeight2 = height - wallcol - 1;\n  } else {\n    newWidth1 = wallrow + 1;\n    newWidth2 = width - wallrow - 1;\n  }\n\n  recursiveDivision(grid, row, col, newHeight1, newWidth1, getOrientation(newHeight1, newWidth1));\n  recursiveDivision(grid, row, col, newHeight2, newWidth2, getOrientation(newHeight2, newWidth2));\n}\nexport function getOrientation(height, width) {\n  if (width < height) {\n    //is horizontal\n    return true;\n  } else if (height < width) {\n    // is vertical\n    return false;\n  } else {\n    const rand = Math.floor(Math.random() * 2);\n    return rand === 0 ? true : false;\n  }\n}\n\nfunction getNeighbors1(node, grid) {\n  // prettier-ignore\n  //console.log('node',node);\n  for (const i of [[-1, 0], [1, 0]]) {\n    const temp = [node.row + i[0], node.col + i[1]]; // check if the neighbor node is within the grid bounds\n    //console.log('temp', temp);\n\n    if (temp[0] < 0 || temp[0] > 29 || temp[1] < 0 || temp[1] > 49) {\n      continue;\n    }\n\n    ;\n    const neighbor = grid[temp[1]][temp[0]]; //console.log('neighbor', neighbor);\n\n    if (neighbor.isWall) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getNeighbors2(node, grid) {\n  // prettier-ignore\n  //console.log('node',node);\n  for (const i of [[0, -1], [0, 1]]) {\n    const temp = [node.row + i[0], node.col + i[1]]; // check if the neighbor node is within the grid bounds\n    //console.log('temp', temp);\n\n    if (temp[0] < 0 || temp[0] > 29 || temp[1] < 0 || temp[1] > 49) {\n      continue;\n    }\n\n    ;\n    const neighbor = grid[temp[1]][temp[0]]; //console.log('neighbor', neighbor);\n\n    if (neighbor.isWall) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["C:/My Projects/pathing-Algorithms/react-app/src/algorithms/mazeGen/recursiveDivision.js"],"names":["recursiveDivision","grid","row","col","height","width","orientation","isHorizontal","wallrow","Math","floor","random","wallcol","console","log","passageRow","passageCol","i","getNeighbors1","isWall","getNeighbors2","newHeight1","newHeight2","newWidth1","newWidth2","getOrientation","rand","node","temp","neighbor"],"mappings":"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","sourcesContent":["export function recursiveDivision(grid,row, col, height, width, orientation){\r\n    if(width < 2 || height < 2)return;\r\n\r\n    let isHorizontal = orientation;\r\n\r\n    //get the column or row that a wall will be drawn in\r\n    const wallrow = row + (isHorizontal ? 0 : Math.floor(Math.random() * (width - 2)));\r\n    const wallcol = col + (isHorizontal ? Math.floor(Math.random() * (height - 2)) : 0);\r\n    console.log(\"wallrow\", wallrow);\r\n    console.log(\"wallcol\", wallcol);\r\n\r\n    //random node in the wall will be selected as a passage\r\n    const passageRow = wallrow + (isHorizontal ? Math.floor(Math.random() * (width - 1)) : 0);\r\n    const passageCol = wallcol + (isHorizontal ? 0 : Math.floor(Math.random() * (height - 1)));\r\n    console.log(\"passrow\", passageRow);\r\n    console.log(\"passcol\", passageCol);\r\n\r\n    //draw the wall\r\n    if(isHorizontal){\r\n        for(let i = 0; i < width; i++){\r\n            if(getNeighbors1(grid[i][wallcol], grid)){\r\n                break;\r\n            }  \r\n            grid[i][wallcol].isWall = true;\r\n        }\r\n    }else{\r\n        for(let i = 0; i < height; i++){\r\n            if(getNeighbors2(grid[i][wallcol], grid)){\r\n                grid[wallrow][i].isWall = true;\r\n            } \r\n        }\r\n    }\r\n    grid[passageRow][passageCol].isWall = false;\r\n\r\n\r\n    let newHeight1 = height;\r\n    let newHeight2 = height;\r\n    let newWidth1 = width;\r\n    let newWidth2= width;\r\n\r\n    if(isHorizontal){\r\n        newHeight1 =  wallcol + 1;\r\n        newHeight2 = height - wallcol -1;\r\n    }else{\r\n        newWidth1 = wallrow + 1;\r\n        newWidth2 = width - wallrow - 1;\r\n    }\r\n    recursiveDivision(grid, row, col, newHeight1, newWidth1, getOrientation(newHeight1, newWidth1));\r\n    recursiveDivision(grid,row, col, newHeight2, newWidth2, getOrientation(newHeight2, newWidth2));\r\n    \r\n}\r\n\r\nexport function getOrientation(height, width){\r\n    if(width < height){//is horizontal\r\n        return true;\r\n    }else if(height < width){ // is vertical\r\n        return false;\r\n    }else{\r\n        const rand = Math.floor(Math.random() * 2);\r\n        return rand === 0  ? true : false;\r\n    }\r\n}\r\n\r\nfunction getNeighbors1(node, grid) {\r\n    // prettier-ignore\r\n    //console.log('node',node);\r\n    for (const i of [[-1, 0],[1, 0]]) {\r\n        const temp = [node.row + i[0], node.col + i[1]];\r\n        // check if the neighbor node is within the grid bounds\r\n        //console.log('temp', temp);\r\n        if(temp[0] < 0 || temp[0] > 29 || temp[1] < 0 || temp[1] > 49){continue};\r\n        \r\n        const neighbor = grid[temp[1]][temp[0]];\r\n        //console.log('neighbor', neighbor);\r\n        if(neighbor.isWall) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction getNeighbors2(node, grid) {\r\n    // prettier-ignore\r\n    //console.log('node',node);\r\n    for (const i of [[0, -1 ],[0, 1]]) {\r\n        const temp = [node.row + i[0], node.col + i[1]];\r\n        // check if the neighbor node is within the grid bounds\r\n        //console.log('temp', temp);\r\n        if(temp[0] < 0 || temp[0] > 29 || temp[1] < 0 || temp[1] > 49){continue};\r\n        \r\n        const neighbor = grid[temp[1]][temp[0]];\r\n        //console.log('neighbor', neighbor);\r\n        if(neighbor.isWall) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"]},"metadata":{},"sourceType":"module"}