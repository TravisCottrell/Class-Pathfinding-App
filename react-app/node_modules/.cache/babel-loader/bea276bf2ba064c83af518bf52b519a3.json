{"ast":null,"code":"export function recursiveDivision(grid, row, col, height, width, orientation, allWalls) {\n  if (width < 3 || height < 3) return;\n  let isHorizontal = orientation;\n  let newHeight1;\n  let newHeight2;\n  let newWidth1;\n  let newWidth2;\n  let col2;\n  let row2;\n  let wallcol = col;\n  let wallrow = row;\n  let hole; //row = y, col = x\n\n  if (isHorizontal) {\n    //random placemnet of a wall on even nodes only\n    wallrow = row + Math.floor(getRandNum(height) / 2) * 2; //random placement of a hole in the wall on odds nodes only \n\n    hole = col + Math.floor(getRandNum(width) / 2) * 2 + 1;\n    newHeight1 = wallrow - row;\n    newWidth1 = width;\n    newHeight2 = row + height - wallrow;\n    newWidth2 = width;\n    row2 = wallrow;\n    col2 = col; //draws the wall \n\n    for (let i = col; i < col + width; i++) {\n      if (i != hole) {\n        grid[i][wallrow].isWall = true;\n        allWalls.push(grid[i][wallrow]);\n      }\n    } //places a hole in the wall\n\n\n    grid[hole][wallrow].isWall = false;\n  } else {\n    //random placemnet of a wall on even nodes only\n    wallcol = col + Math.floor(getRandNum(width) / 2) * 2; //random placement of a hole in the wall on odds nodes only \n\n    hole = row + Math.floor(getRandNum(height) / 2) * 2 + 1;\n    newHeight1 = height;\n    newWidth1 = wallcol - col;\n    newHeight2 = height;\n    newWidth2 = col + width - wallcol;\n    row2 = row;\n    col2 = wallcol; //draws the wall\n\n    for (let i = row; i < row + height; i++) {\n      if (i != hole) {\n        grid[wallcol][i].isWall = true;\n        allWalls.push(grid[wallcol][i]);\n      }\n    } //places a hole in the wall\n    //grid[wallcol][hole].isWall = false;\n\n  }\n\n  recursiveDivision(grid, row, col, newHeight1, newWidth1, getOrientation(newHeight1, newWidth1));\n  recursiveDivision(grid, row2, col2, newHeight2, newWidth2, getOrientation(newHeight2, newWidth2));\n}\nexport function getOrientation(height, width) {\n  if (width < height) {\n    //is horizontal\n    return true;\n  } else if (height < width) {\n    // is vertical\n    return false;\n  } else {\n    const rand = Math.floor(Math.random() * 2);\n    return rand === 0 ? true : false;\n  }\n}\n\nfunction getRandNum(max) {\n  return Math.floor(Math.random() * max);\n}","map":{"version":3,"sources":["C:/My Projects/pathing-Algorithms/react-app/src/algorithms/mazeGen/recursiveDivision.js"],"names":["recursiveDivision","grid","row","col","height","width","orientation","allWalls","isHorizontal","newHeight1","newHeight2","newWidth1","newWidth2","col2","row2","wallcol","wallrow","hole","Math","floor","getRandNum","i","isWall","push","getOrientation","rand","random","max"],"mappings":"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","sourcesContent":["export function recursiveDivision(grid,row, col, height, width, orientation, allWalls){\r\n    if(width < 3 || height < 3)return;\r\n    \r\n    \r\n    let isHorizontal = orientation;\r\n    let newHeight1;\r\n    let newHeight2;\r\n    let newWidth1;\r\n    let newWidth2;\r\n    let col2;\r\n    let row2;\r\n    let wallcol = col;\r\n    let wallrow = row;\r\n    let hole;\r\n    \r\n    //row = y, col = x\r\n    if(isHorizontal){\r\n        //random placemnet of a wall on even nodes only\r\n        wallrow = row + Math.floor(getRandNum(height)/2) * 2;\r\n        //random placement of a hole in the wall on odds nodes only \r\n        hole = col + Math.floor(getRandNum(width)/ 2) * 2 + 1;\r\n\r\n        newHeight1 = wallrow - row;\r\n        newWidth1 = width;\r\n\r\n        newHeight2 = row + height - wallrow;\r\n        newWidth2 = width;\r\n\r\n        row2 = wallrow;\r\n        col2 = col;\r\n        \r\n        //draws the wall \r\n        for(let i = col; i < col+width; i++){\r\n            if(i != hole){\r\n                grid[i][wallrow].isWall = true;\r\n                allWalls.push( grid[i][wallrow]);\r\n            }\r\n        }\r\n\r\n        //places a hole in the wall\r\n        grid[hole][wallrow].isWall = false;\r\n\r\n\r\n    }else{\r\n        //random placemnet of a wall on even nodes only\r\n        wallcol = col + Math.floor(getRandNum(width)/ 2) * 2;\r\n        //random placement of a hole in the wall on odds nodes only \r\n        \r\n        hole = row + Math.floor(getRandNum(height)/ 2)  * 2 + 1;\r\n\r\n        newHeight1 = height;\r\n        newWidth1 = wallcol - col;\r\n\r\n        newHeight2 = height;\r\n        newWidth2 = col + width - wallcol;\r\n\r\n        row2 = row;\r\n        col2 = wallcol;\r\n       \r\n        //draws the wall\r\n        for(let i = row; i < row + height; i++){\r\n            if(i != hole){\r\n                grid[wallcol][i].isWall = true;\r\n                allWalls.push(grid[wallcol][i]);\r\n             }\r\n        }\r\n\r\n        //places a hole in the wall\r\n        //grid[wallcol][hole].isWall = false;\r\n\r\n\r\n    }\r\n\r\n    recursiveDivision(grid, row, col, newHeight1, newWidth1, getOrientation(newHeight1, newWidth1));\r\n    recursiveDivision(grid, row2, col2, newHeight2, newWidth2, getOrientation(newHeight2, newWidth2));\r\n    \r\n}\r\n\r\nexport function getOrientation(height, width){\r\n    if(width < height){//is horizontal\r\n        return true;\r\n    }else if(height < width){ // is vertical\r\n        return false;\r\n    }else{\r\n        const rand = Math.floor(Math.random() * 2);\r\n        return rand === 0  ? true : false;\r\n    }\r\n}\r\n\r\nfunction getRandNum(max) {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}