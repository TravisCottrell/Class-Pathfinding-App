{"ast":null,"code":"export function dijkstra(start, end, grid) {\n  let unvistedNodes = getNodes(grid);\n  let vistedNodes = [];\n  start.distance = 0; //while (unvistedNodes.length >= 0) {\n\n  sortNodes(unvistedNodes);\n  console.log(unvistedNodes);\n  const currentNode = unvistedNodes.shift();\n  console.log('currentnode', currentNode);\n  const neighbors = getNeighbors(currentNode, grid); //}\n} //turns the 2d array into a 1d array for easier usage\n\nfunction getNodes(grid) {\n  const newGrid = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      newGrid.push(node);\n    }\n  }\n\n  return newGrid;\n}\n\nfunction sortNodes(unvisitedNodes) {\n  unvisitedNodes.sort((a, b) => a.distance - b.distance);\n}\n\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n\n  for (const i of [[0, -1], [0, 1], [-1, 0], [1, 0]]) {\n    const temp = [node.row + i[0], node.col + i[1]];\n    console.log('temp', temp);\n    const neighbor = grid[temp[0]][temp[1]];\n    console.log(neighbor); // if(!temp.isWall){\n    //     neighbors.push(neighbor);\n    // }\n  }\n\n  return neighbors;\n}","map":{"version":3,"sources":["C:/My Projects/pathing-Algorithms/react-app/src/algorithms/dijkstra.js"],"names":["dijkstra","start","end","grid","unvistedNodes","getNodes","vistedNodes","distance","sortNodes","console","log","currentNode","shift","neighbors","getNeighbors","newGrid","row","node","push","unvisitedNodes","sort","a","b","i","temp","col","neighbor"],"mappings":"AAAA,OAAO,SAASA,QAAT,CAAkBC,KAAlB,EAAyBC,GAAzB,EAA8BC,IAA9B,EAAoC;AACvC,MAAIC,aAAa,GAAGC,QAAQ,CAACF,IAAD,CAA5B;AACA,MAAIG,WAAW,GAAG,EAAlB;AACAL,EAAAA,KAAK,CAACM,QAAN,GAAiB,CAAjB,CAHuC,CAMvC;;AACIC,EAAAA,SAAS,CAACJ,aAAD,CAAT;AACAK,EAAAA,OAAO,CAACC,GAAR,CAAYN,aAAZ;AACA,QAAMO,WAAW,GAAGP,aAAa,CAACQ,KAAd,EAApB;AACAH,EAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2BC,WAA3B;AACA,QAAME,SAAS,GAAGC,YAAY,CAACH,WAAD,EAAcR,IAAd,CAA9B,CAXmC,CAavC;AACH,C,CAGD;;AACA,SAASE,QAAT,CAAkBF,IAAlB,EAAuB;AACnB,QAAMY,OAAO,GAAG,EAAhB;;AACA,OAAI,MAAMC,GAAV,IAAiBb,IAAjB,EAAsB;AAClB,SAAI,MAAMc,IAAV,IAAkBD,GAAlB,EAAsB;AAClBD,MAAAA,OAAO,CAACG,IAAR,CAAaD,IAAb;AACH;AACJ;;AACD,SAAOF,OAAP;AACH;;AAED,SAASP,SAAT,CAAmBW,cAAnB,EAAkC;AAC9BA,EAAAA,cAAc,CAACC,IAAf,CAAoB,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACd,QAAF,GAAae,CAAC,CAACf,QAA7C;AACH;;AAED,SAASO,YAAT,CAAsBG,IAAtB,EAA4Bd,IAA5B,EAAiC;AAC7B,QAAMU,SAAS,GAAG,EAAlB;;AACA,OAAI,MAAMU,CAAV,IAAe,CAAC,CAAC,CAAD,EAAI,CAAC,CAAL,CAAD,EAAU,CAAC,CAAD,EAAI,CAAJ,CAAV,EAAkB,CAAC,CAAC,CAAF,EAAK,CAAL,CAAlB,EAA2B,CAAC,CAAD,EAAI,CAAJ,CAA3B,CAAf,EAAkD;AAC9C,UAAMC,IAAI,GAAG,CAACP,IAAI,CAACD,GAAL,GAAWO,CAAC,CAAC,CAAD,CAAb,EAAkBN,IAAI,CAACQ,GAAL,GAAWF,CAAC,CAAC,CAAD,CAA9B,CAAb;AACAd,IAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ,EAAoBc,IAApB;AACA,UAAME,QAAQ,GAAGvB,IAAI,CAACqB,IAAI,CAAC,CAAD,CAAL,CAAJ,CAAcA,IAAI,CAAC,CAAD,CAAlB,CAAjB;AACAf,IAAAA,OAAO,CAACC,GAAR,CAAYgB,QAAZ,EAJ8C,CAK9C;AACA;AACA;AACH;;AACD,SAAOb,SAAP;AACH","sourcesContent":["export function dijkstra(start, end, grid) {\r\n    let unvistedNodes = getNodes(grid);\r\n    let vistedNodes = [];\r\n    start.distance = 0;\r\n    \r\n    \r\n    //while (unvistedNodes.length >= 0) {\r\n        sortNodes(unvistedNodes);\r\n        console.log(unvistedNodes);\r\n        const currentNode = unvistedNodes.shift();\r\n        console.log('currentnode', currentNode);\r\n        const neighbors = getNeighbors(currentNode, grid);\r\n        \r\n    //}\r\n}\r\n\r\n\r\n//turns the 2d array into a 1d array for easier usage\r\nfunction getNodes(grid){\r\n    const newGrid = [];\r\n    for(const row of grid){\r\n        for(const node of row){\r\n            newGrid.push(node);\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\n\r\nfunction sortNodes(unvisitedNodes){\r\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\r\n}\r\n\r\nfunction getNeighbors(node, grid){\r\n    const neighbors = [];\r\n    for(const i of [[0, -1], [0, 1], [-1, 0], [1, 0]]){        \r\n        const temp = [node.row + i[0], node.col + i[1]];\r\n        console.log('temp', temp);\r\n        const neighbor = grid[temp[0]][temp[1]];\r\n        console.log(neighbor);\r\n        // if(!temp.isWall){\r\n        //     neighbors.push(neighbor);\r\n        // }\r\n    }\r\n    return neighbors;\r\n}"]},"metadata":{},"sourceType":"module"}