{"ast":null,"code":"export function recursiveDivision(grid, row, col, height, width, orientation) {\n  if (width < 3 || height < 3) return;\n  let isHorizontal = orientation; //get the column or row that a wall will be drawn in\n\n  const wallcol = isHorizontal ? 0 : getRandNum(row, width - 2);\n  const wallrow = isHorizontal ? getRandNum(col, height - 2) : 0;\n  console.log(\"wallcol\", wallcol);\n  console.log(\"wallrow\", wallrow); //random node in the wall will be selected as a passage\n\n  const passageCol = wallcol + (isHorizontal ? getRandNum(row, width - 1) : 0);\n  const passageRow = wallrow + (isHorizontal ? 0 : getRandNum(col, height - 1));\n  console.log(\"passrow\", passageRow);\n  console.log(\"passcol\", passageCol);\n  console.log('node: ', grid[passageCol][passageRow]);\n  console.log(\"---------------------\"); //draw the wall\n\n  if (isHorizontal) {\n    if (row < width) {\n      for (let i = row; i < width; i++) {\n        grid[i][wallrow].isWall = true;\n      }\n    } else {\n      for (let i = width; i < row; i++) {\n        grid[i][wallrow].isWall = true;\n      }\n    }\n  } else {\n    if (col < height) {\n      for (let i = col; i < height; i++) {\n        grid[wallcol][i].isWall = true;\n      }\n    } else {\n      for (let i = height; i < col; i++) {\n        grid[wallcol][i].isWall = true;\n      }\n    }\n  }\n\n  grid[passageCol][passageRow].isWall = false;\n  let newHeight1 = height;\n  let newHeight2 = height;\n  let newWidth1 = width;\n  let newWidth2 = width;\n\n  if (isHorizontal) {\n    newHeight1 = wallrow;\n    newHeight2 = height - wallrow;\n  } else {\n    newWidth1 = wallcol;\n    newWidth2 = width - wallcol;\n  }\n\n  recursiveDivision(grid, wallrow, wallcol, newHeight1, newWidth1, getOrientation(newHeight1, newWidth1)); //recursiveDivision(grid, wallrow, wallcol, newHeight2, newWidth2, getOrientation(newHeight2, newWidth2));\n}\nexport function getOrientation(height, width) {\n  if (width < height) {\n    //is horizontal\n    return true;\n  } else if (height < width) {\n    // is vertical\n    return false;\n  } else {\n    const rand = Math.floor(Math.random() * 2);\n    return rand === 0 ? true : false;\n  }\n}\n\nfunction getRandNum(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}","map":{"version":3,"sources":["C:/My Projects/pathing-Algorithms/react-app/src/algorithms/mazeGen/recursiveDivision.js"],"names":["recursiveDivision","grid","row","col","height","width","orientation","isHorizontal","wallcol","getRandNum","wallrow","console","log","passageCol","passageRow","i","isWall","newHeight1","newHeight2","newWidth1","newWidth2","getOrientation","rand","Math","floor","random","min","max"],"mappings":"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","sourcesContent":["export function recursiveDivision(grid,row, col, height, width, orientation){\r\n    if(width < 3 || height < 3)return;\r\n\r\n    let isHorizontal = orientation;\r\n\r\n    //get the column or row that a wall will be drawn in\r\n    const wallcol = (isHorizontal ? 0 : getRandNum(row, (width - 2)));\r\n    const wallrow = (isHorizontal ? getRandNum(col, (height - 2)) : 0);\r\n    console.log(\"wallcol\", wallcol);\r\n    console.log(\"wallrow\", wallrow);\r\n\r\n    //random node in the wall will be selected as a passage\r\n    const passageCol = wallcol + (isHorizontal ? getRandNum(row, (width - 1)) : 0);\r\n    const passageRow = wallrow + (isHorizontal ? 0 : getRandNum(col, (height - 1)));\r\n    console.log(\"passrow\", passageRow);\r\n    console.log(\"passcol\", passageCol);\r\n    console.log('node: ',grid[passageCol][passageRow]);\r\n    console.log(\"---------------------\");\r\n\r\n    //draw the wall\r\n    if(isHorizontal){\r\n        if(row < width){\r\n            for(let i = row; i < width; i++){\r\n                grid[i][wallrow].isWall = true;\r\n            }\r\n        }else{\r\n            for(let i = width; i < row; i++){\r\n                grid[i][wallrow].isWall = true;\r\n            }  \r\n        }\r\n    }else{\r\n        if(col < height){\r\n            for(let i = col; i < height; i++){\r\n                grid[wallcol][i].isWall = true; \r\n            }\r\n        }\r\n        else{\r\n            for(let i = height; i < col; i++){\r\n                grid[wallcol][i].isWall = true; \r\n            }\r\n        }\r\n    }\r\n    \r\n    grid[passageCol][passageRow].isWall = false;\r\n\r\n\r\n    let newHeight1 = height;\r\n    let newHeight2 = height;\r\n    let newWidth1 = width;\r\n    let newWidth2= width;\r\n\r\n    if(isHorizontal){\r\n        newHeight1 =  wallrow;\r\n        newHeight2 = height - wallrow;\r\n    }else{\r\n        newWidth1 = wallcol;\r\n        newWidth2 = width - wallcol;\r\n    }\r\n    recursiveDivision(grid, wallrow, wallcol, newHeight1, newWidth1, getOrientation(newHeight1, newWidth1));\r\n    //recursiveDivision(grid, wallrow, wallcol, newHeight2, newWidth2, getOrientation(newHeight2, newWidth2));\r\n    \r\n}\r\n\r\nexport function getOrientation(height, width){\r\n    if(width < height){//is horizontal\r\n        return true;\r\n    }else if(height < width){ // is vertical\r\n        return false;\r\n    }else{\r\n        const rand = Math.floor(Math.random() * 2);\r\n        return rand === 0  ? true : false;\r\n    }\r\n}\r\n\r\nfunction getRandNum(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) ) + min;\r\n  }\r\n\r\n"]},"metadata":{},"sourceType":"module"}