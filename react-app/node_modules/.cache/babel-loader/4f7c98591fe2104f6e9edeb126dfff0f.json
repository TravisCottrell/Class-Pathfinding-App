{"ast":null,"code":"export function dijkstra(start, end, grid) {\n  let unvistedNodes = getNodes(grid);\n  let vistedNodes = [];\n  start.distance = 0;\n  start.isVisited = true;\n\n  while (unvistedNodes.length > 0) {\n    sortNodes(unvistedNodes);\n    const currentNode = unvistedNodes.shift();\n    if (currentNode.distance === Infinity) return vistedNodes;\n    currentNode.isVisited = true;\n    vistedNodes.push(currentNode);\n    if (currentNode === end) return vistedNodes;\n    getNeighbors(currentNode, grid);\n  }\n} //turns the 2d array into a 1d array for easier usage\n\nfunction getNodes(grid) {\n  const newGrid = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      newGrid.push(node);\n    }\n  }\n\n  return newGrid;\n}\n\nfunction sortNodes(unvisitedNodes) {\n  unvisitedNodes.sort((a, b) => a.distance - b.distance);\n}\n\nfunction getNeighbors(node, grid) {\n  // prettier-ignore\n  //loop to get the neighbors in the up/down/left/right positions of the current node\n  for (const i of [[0, -1], [0, 1], [-1, 0], [1, 0]]) {\n    const neighborPosition = [node.row + i[0], node.col + i[1]]; // check if the neighbor node is within the grid bounds\n\n    if (neighborPosition[0] < 0 || neighborPosition[0] > grid[0].length - 1 || neighborPosition[1] < 0 || neighborPosition[1] > grid.length - 1) {\n      continue;\n    }\n\n    ;\n    const neighbor = grid[neighborPosition[1]][neighborPosition[0]];\n\n    if (!neighbor.isWall && !neighbor.isVisited) {\n      neighbor.distance = node.distance + 1;\n      neighbor.prevNode = node;\n    }\n  }\n}\n\nexport function getShortestPath(endNode) {\n  const path = [];\n  let currentNode = endNode;\n\n  while (currentNode != null) {\n    path.push(currentNode);\n    currentNode = currentNode.prevNode;\n  }\n\n  return path;\n}","map":{"version":3,"sources":["C:/My Projects/pathing-Algorithms/react-app/src/algorithms/pathFinding/dijkstra.js"],"names":["dijkstra","start","end","grid","unvistedNodes","getNodes","vistedNodes","distance","isVisited","length","sortNodes","currentNode","shift","Infinity","push","getNeighbors","newGrid","row","node","unvisitedNodes","sort","a","b","i","neighborPosition","col","neighbor","isWall","prevNode","getShortestPath","endNode","path"],"mappings":"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","sourcesContent":["export function dijkstra(start, end, grid) {\r\n    let unvistedNodes = getNodes(grid);\r\n    let vistedNodes = [];\r\n    start.distance = 0;\r\n    start.isVisited = true;\r\n\r\n    while (unvistedNodes.length > 0) {\r\n        sortNodes(unvistedNodes);\r\n        const currentNode = unvistedNodes.shift();\r\n        if(currentNode.distance === Infinity) return vistedNodes;\r\n        currentNode.isVisited = true;\r\n        vistedNodes.push(currentNode);\r\n        if (currentNode === end) return vistedNodes;\r\n        getNeighbors(currentNode, grid);\r\n    }\r\n}\r\n\r\n//turns the 2d array into a 1d array for easier usage\r\nfunction getNodes(grid) {\r\n    const newGrid = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            newGrid.push(node);\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\n\r\nfunction sortNodes(unvisitedNodes) {\r\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n    // prettier-ignore\r\n    //loop to get the neighbors in the up/down/left/right positions of the current node\r\n    for (const i of [[0, -1],[0, 1],[-1, 0],[1, 0]]) {\r\n        const neighborPosition = [node.row + i[0], node.col + i[1]];\r\n\r\n        // check if the neighbor node is within the grid bounds\r\n        if(neighborPosition[0] < 0 || neighborPosition[0] > grid[0].length-1 || neighborPosition[1] < 0 || neighborPosition[1] > grid.length-1){continue};\r\n        \r\n        const neighbor = grid[neighborPosition[1]][neighborPosition[0]];\r\n        if(!neighbor.isWall && !neighbor.isVisited) {\r\n            neighbor.distance = node.distance + 1;\r\n            neighbor.prevNode = node; \r\n        }\r\n    }\r\n}\r\n\r\nexport function getShortestPath(endNode){\r\n    const path = [];\r\n    let currentNode = endNode;\r\n    while(currentNode != null){\r\n        path.push(currentNode);\r\n        currentNode = currentNode.prevNode;\r\n    }\r\n    return path;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}