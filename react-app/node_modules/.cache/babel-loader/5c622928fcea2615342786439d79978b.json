{"ast":null,"code":"export function dijkstra(start, end, grid) {\n  let unvistedNodes = getNodes(grid);\n  let vistedNodes = [];\n  start.distance = 0;\n\n  while (unvistedNodes.length >= 0) {\n    sortNodes(unvistedNodes);\n    const currentNode = unvistedNodes.shift();\n  }\n} //turns the 2d array into a 1d array for easier usage\n\nfunction getNodes(grid) {\n  const newGrid = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      newGrid.push(node);\n    }\n  }\n\n  return newGrid;\n}\n\nfunction sortNodes(unvisitedNodes) {\n  unvisitedNodes.sort((a, b) => a.distance - b.distance);\n}\n\nfunction getNeighbors(node, grid) {\n  neighbors = [];\n\n  for (i of [(0, -1), (0, 1), (-1, 0), (1, 0)]) {\n    neighbor = (node.row + i[0], node.col + i[1]);\n    temp = grid[neighbor[0]][neighbor[1]];\n\n    if (!temp.isWall) {}\n  }\n}","map":{"version":3,"sources":["C:/My Projects/pathing-Algorithms/react-app/src/algorithms/dijkstra.js"],"names":["dijkstra","start","end","grid","unvistedNodes","getNodes","vistedNodes","distance","length","sortNodes","currentNode","shift","newGrid","row","node","push","unvisitedNodes","sort","a","b","getNeighbors","neighbors","i","neighbor","col","temp","isWall"],"mappings":"AAAA,OAAO,SAASA,QAAT,CAAkBC,KAAlB,EAAyBC,GAAzB,EAA8BC,IAA9B,EAAoC;AACvC,MAAIC,aAAa,GAAGC,QAAQ,CAACF,IAAD,CAA5B;AACA,MAAIG,WAAW,GAAG,EAAlB;AACAL,EAAAA,KAAK,CAACM,QAAN,GAAiB,CAAjB;;AAEA,SAAOH,aAAa,CAACI,MAAd,IAAwB,CAA/B,EAAkC;AAC9BC,IAAAA,SAAS,CAACL,aAAD,CAAT;AACA,UAAMM,WAAW,GAAGN,aAAa,CAACO,KAAd,EAApB;AACH;AACJ,C,CAGD;;AACA,SAASN,QAAT,CAAkBF,IAAlB,EAAuB;AACnB,QAAMS,OAAO,GAAG,EAAhB;;AACA,OAAI,MAAMC,GAAV,IAAiBV,IAAjB,EAAsB;AAClB,SAAI,MAAMW,IAAV,IAAkBD,GAAlB,EAAsB;AAClBD,MAAAA,OAAO,CAACG,IAAR,CAAaD,IAAb;AACH;AACJ;;AACD,SAAOF,OAAP;AACH;;AAED,SAASH,SAAT,CAAmBO,cAAnB,EAAkC;AAC9BA,EAAAA,cAAc,CAACC,IAAf,CAAoB,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACX,QAAF,GAAaY,CAAC,CAACZ,QAA7C;AACH;;AAED,SAASa,YAAT,CAAsBN,IAAtB,EAA4BX,IAA5B,EAAiC;AAC7BkB,EAAAA,SAAS,GAAG,EAAZ;;AACA,OAAIC,CAAJ,IAAS,EAAE,GAAG,CAAC,CAAN,IAAW,GAAG,CAAd,IAAmB,CAAC,CAAD,EAAI,CAAvB,IAA4B,GAAG,CAA/B,EAAT,EAA4C;AACxCC,IAAAA,QAAQ,IAAIT,IAAI,CAACD,GAAL,GAAWS,CAAC,CAAC,CAAD,CAAZ,EAAiBR,IAAI,CAACU,GAAL,GAAWF,CAAC,CAAC,CAAD,CAAjC,CAAR;AACAG,IAAAA,IAAI,GAAGtB,IAAI,CAACoB,QAAQ,CAAC,CAAD,CAAT,CAAJ,CAAkBA,QAAQ,CAAC,CAAD,CAA1B,CAAP;;AAEA,QAAG,CAACE,IAAI,CAACC,MAAT,EAAgB,CAEf;AACJ;AACJ","sourcesContent":["export function dijkstra(start, end, grid) {\r\n    let unvistedNodes = getNodes(grid);\r\n    let vistedNodes = [];\r\n    start.distance = 0;\r\n    \r\n    while (unvistedNodes.length >= 0) {\r\n        sortNodes(unvistedNodes);\r\n        const currentNode = unvistedNodes.shift();\r\n    }\r\n}\r\n\r\n\r\n//turns the 2d array into a 1d array for easier usage\r\nfunction getNodes(grid){\r\n    const newGrid = [];\r\n    for(const row of grid){\r\n        for(const node of row){\r\n            newGrid.push(node);\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\n\r\nfunction sortNodes(unvisitedNodes){\r\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\r\n}\r\n\r\nfunction getNeighbors(node, grid){\r\n    neighbors = [];\r\n    for(i of [(0, -1), (0, 1), (-1, 0), (1, 0)]){\r\n        neighbor = (node.row + i[0], node.col + i[1]);\r\n        temp = grid[neighbor[0]][neighbor[1]]\r\n    \r\n        if(!temp.isWall){\r\n            \r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}